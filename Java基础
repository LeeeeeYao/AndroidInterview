
一、面向对象编程相关问题
问：请简单介绍一下面向对象编程中的封装、继承和多态。
答：封装、继承和多态是面向对象编程的三大核心特性，对 Android 开发特别重要。
封装，就是把对象的一些属性和操作 “包” 在一起，让它变成一个独立的小单元，同时尽量藏起内部的实现细节。比如，在 Android 里定义一个 User 类，把用户的姓名、年龄这些属性藏起来，外面只能通过类里的公开方法，像 getName() 和 setName() 去获取或修改，这样既能保护数据，又让代码更有条理。
继承呢，挺好理解的，就是子类能直接 “接上” 父类的属性和方法，不用重复写一大堆代码。比如咱们常见的 Button 类继承自 TextView，这样按钮就直接拥有了文本视图的很多功能，像显示文字之类的，同时还能自己添加新功能，比如处理点击事件，这就是典型的代码复用，效率超高。
多态，这个稍微有点抽象，大白话讲就是一种 “父子变形记”。比如有一个父类叫 Animal，然后子类有 Dog 和 Cat，它们都有 makeSound() 方法。当把一个 Dog 对象当 Animal 对象用，调 makeSound() 时，出来的声音是 “汪汪汪”；把 Cat 当 Animal 用时，声音就是 “喵喵喵”。这样根据对象实际类型动态改变行为，特别灵活，在处理类似 Adapter 适配数据源这种场景时用处特别大，能写出很简洁但功能强大的代码。
问：封装的好处是什么？在实际开发中，你是怎么运用封装的？能举个例子吗？
答：封装的好处太多了！
首先，它保障数据安全啊。比如类里有一个敏感数据，像用户余额，我可以通过封装把余额属性设成私有，外面不能直接动它。然后我设计一些带有逻辑的方法，比如 deposit() 存钱和 withdraw() 取钱，方法里会检查金额合法性。这样就能避免余额被非法篡改，比如用户不能直接把余额改成负数。
其次，封装让代码更模块化，可维护性好。比如说我写了一个处理图片的类，把图片加载、旋转、裁剪这些操作都封装在类里。如果以后业务需求变了，比如图片裁剪方式要改，我只用在类内部改，外面调用的地方不用动，特别省事。
具体的例子，比如在 Android 开发里，我们经常会封装一个自定义的 LoadingDialog 弹窗类。我把弹窗显示、隐藏、设置提示文字这些功能封装在里面。外部调用的时候，不用关心弹窗内部是怎么画出来的、怎么消失的，只需要调 show() 方法，传个上下文和提示文字就能显示，调 dismiss() 就能隐藏，简单又高效，到处都能用。

二、Java 基础知识相关问题
问：基本数据类型和引用类型有什么区别？你在用它们的时候分别注意些什么？
答：基本数据类型和引用类型，这可是 Java 里很基础但极其重要的知识点。
基本数据类型就像一个个装简单值的 “小盒子”，比如 int 就存整数，double 存小数，boolean 存 true 或 false。它们的特点是，存储的是实实在在的值，而且占用的空间是固定的，比如 int 总是占 4 个字节。用的时候得注意范围，比如 int 最大表示 2 的 31 次方减 1，超出范围就可能会出错，像在计算特别大的数据的时候，得想想用 long 或者其他类型。
引用类型呢，可以看成是一个指向对象的 “指针”，它存的不是真正的数据，而是一个 “地址”。比如说 String、ArrayList 这些对象类型。比如我定义一个 String 变量，其实它是指向堆内存里的字符串对象的位置。用引用类型的时候，得特别注意空指针异常，因为如果变量是 null，直接调用它的方法，程序就会直接崩掉。比如在 Android 开发中获取 EditText 的文本内容时，得先判断它是不是空的，不然就会出问题。
总的来说，基本数据类型更轻量、直接，引用类型更灵活、功能强大，但得小心空指针和内存管理之类的麻烦事。
问：你能区别一下 == 和 .equals() 这两个方法的区别吗？在实际开发中怎么应用？
答：这两个方法经常容易混淆，但区别其实挺大。
==，这比较的是内存地址的值。对于基本数据类型，它就是直接比较两个值是不是相等，比如 int a = 5; int b = 5; a == b 会返回 true。对于引用类型，它比较的是两个对象是否指向同一块内存地址。比如我有两个 String 类型的变量：
java复制
String s1 = "hello";
String s2 = "hello";
这俩 == 比较是 true，因为它们在字符串常量池里其实是同一个对象。但如果我这么写：
java复制
String s1 = new String("hello");
String s2 = new String("hello");
这时候 s1 == s2 就是 false，因为它们是两个不同的对象，虽然内容一样，但内存地址不一样。
而 .equals() 是个方法，主要是用来比较对象的内容是否相等。还是用上面的例子，不管用哪种方式初始化的字符串，s1.equals(s2) 都是 true，因为内容都是 “hello”。这个方法允许我们定义自己的比较逻辑，比如我写一个 Person 类，我可以通过重写 .equals() 方法，让两个 Person 对象根据姓名、年龄这些属性来判断是否相等。
在实际开发中，比如在处理用户输入时，比较两个 String 是不是相同，我一般用 .equals()，避免 == 带来的意外错误。再比如比较两个自定义对象是否相等时，我也会通过重写 .equals() 来实现。

三、集合框架相关问题
问：Android 开发中，ArrayList 和 LinkedList 的区别是什么？你什么时候会选择用哪一个？
答：这两个集合类，各有各的特点，选择的时候得看具体场景。
ArrayList 就好像一个可以直接随机访问的大队列。它的底层是数组结构，所以随机访问特别快，比如我知道第 5 个元素要它的值，直接通过索引就能快速拿到。但是，如果我要在中间插入或删除一个元素，那就比较慢了，因为后面的元素都要跟着往后或往前移，特别是数据量大的时候，性能会受影响。在 Android 开发里，比如我要显示一个列表，数据加载完后很少变化，直接用 ArrayList 很合适，像在 RecyclerView 里显示一些静态的数据列表，方便获取指定位置的元素。
而 LinkedList 是双向链表结构，它的特点是插入和删除快，比如在链表中间加个元素，只需要改几个指针的指向就行，很快。但它的随机访问就很慢，因为要从头或者尾一个一个元素找过去。在 Android 开发中，如果场景需要频繁添加删除元素，比如一个即时聊天的消息列表，新消息不断插入，或者用户可以删除中间的消息，这时候用 LinkedList 就比较合适。
总之，数据访问多、改动少用 ArrayList；数据改动频繁、访问少用 LinkedList。
问：请解释一下 HashMap 和 TreeMap 的不同点。
答：这两个是 Java 中常用的 Map 类，它们的区别很明显。
HashMap 是基于哈希表实现的，这是一种通过哈希算法把键值对存储在内存里的方式。它的优点是存取速度快，因为哈希表能根据键的哈希值快速定位到对应的值。而且它对于键没有强制的顺序要求，所以键值对的顺序是随机的。在 Android 开发里，比如我们用 HashMap 来存储一些临时的数据映射，比如资源 ID 和对应的描述信息，用起来特别高效，因为不用考虑键的顺序。
TreeMap 则是基于红黑树的，它的特点是会根据键的自然顺序或者我们自定义的比较器对键进行排序。这样，在遍历时是按照键的顺序来的，很有条理。比如我们要存储一些需要按字母顺序排序的联系人名字和联系方式，用 TreeMap 就很方便，遍历出来的结果是按名字首字母顺序排列好的。不过，TreeMap 的性能略低于 HashMap，特别是在数据量大的时候，因为每次插入都要调整树的结构来保持顺序。
总的来说，需要快速存取、不关心顺序用 HashMap；需要按顺序存取，或者要求键有序用 TreeMap。

四、异常处理相关问题
问：请解释一下 Java 中的异常体系结构，Error 和 Exception 有什么区别？
答：Java 的异常体系感觉就像一个家族树，根节点是 Throwable 类，Error 和 Exception 是它的两个主要分支。
Error 类就像家族里的 “大家族长”，它表示一些严重影响程序运行的错误，是 JVM 级别的问题，比如内存溢出（OutOfMemoryError），这就意味着程序可能没法正常运行下去了。这种错误通常咱们开发者没法处理，只能想办法优化内存使用，或者修改程序结构。
Exception 类则是日常工作中更常见的一类异常，它分为运行时异常（RuntimeException）和受检异常。运行时异常一般是编程错误导致的，比如空指针异常（NullPointerException），这种异常理论上可以通过改代码来避免，比如提前判断对象是否为空。受检异常则需要我们在编写代码时强制处理，比如读写文件可能会抛出的 IOException，在这种情况下，要么用 try-catch 捕获异常，要么用 throws 抛给上层调用者处理。
简单来说，Error 是程序的“致命电击”，Exception 是程序的“可预见小病痛”，得注意处理和预防。
问：在 Android 开发中，你是如何处理异常的？能举一个实际的例子吗？
答：在 Android 开发里，异常处理是避免程序崩溃的关键。
比如说，我写了一个方法，通过网络去获取数据。由于网络环境不可控，可能出现网络请求超时、服务器返回错误码等异常情况。这时候我就会用到 try-catch。
java复制
public void fetchData() {
    try {
        // 模拟网络请求
        String result = new NetworkRequest().execute();
        // 处理数据
        processResult(result);
    } catch (IOException e) {
        // 捕获网络通信异常
        Toast.makeText(context, "网络请求失败，请检查网络连接", Toast.LENGTH_SHORT).show();
        Log.e("NetworkError", "IOException occurred: " + e.getMessage());
    } catch (JSONException e) {
        // 捕获解析 JSON 数据异常
        Toast.makeText(context, "数据解析失败，请重试", Toast.LENGTH_SHORT).show();
        Log.e("DataError", "JSONException occurred: " + e.getMessage());
    } catch (Exception e) {
        // 捕获其他未知异常
        Toast.makeText(context, "未知错误发生，请重试", Toast.LENGTH_SHORT).show();
        Log.e("UnknownError", "Exception occurred: " + e.getMessage());
    }
}
在这个例子中，我在网络请求的代码块外面套了一个 try，然后用多个 catch 分别捕获不同类型的异常。假如发生 IOException，我就通过 Toast 提示用户网络请求失败，同时在 Log 里记录详细的错误日志，方便后续排查问题。如果是 JSONException，就提示数据解析失败，同样记录日志。最后还有一个通用的 catch，确保其他未知异常也能被捕获到，避免程序直接崩溃。这样处理下来，程序在遇到异常时就不会大撒把，用户也能得到友好的反馈，开发者也能通过日志定位问题。

五、多线程编程相关问题
问：在 Android 开发中，为什么要用多线程？你能举一个需要使用多线程的场景吗？
答：因为 Android 的主线程（也叫 UI 线程）负责处理用户界面的绘制和事件分发。如果主线程被卡住，比如在做长时间的计算、处理大量数据或者等待网络请求结果，整个 App 的界面就会卡住，不能响应用户的点击呀、滑动呀这些操作，用户体验就会变得很差，甚至可能被系统判定为卡死，强制关闭。
所以，遇到这些耗时操作，我们就需要多线程。比如一个需要加载远程图片的场景。假设用户在一个商品详情页面，里面有显示一张大图。如果直接在主线程下载图片，那整个页面就会卡住，直到图片下载完成。这时候我们就可以用多线程：
开启一个子线程，专门去网络上下载图片数据。
在子线程完成下载后，将图片数据交由主线程的 UI 线程去显示到 ImageView 上。
像这样，主线程继续负责处理用户的交互，子线程负责耗时的网络请求和图片处理，两者各司其职，就不会出现卡顿了。
问：请解释一下 synchronized 关键字的作用和它的使用场景。
答：synchronized 关键字的主要作用就是保证线程安全。
在多线程环境下，如果多个线程同时访问和修改同一个共享资源，可能会导致数据错乱或者出现意想不到的结果。这时候 synchronized 就像一个 “安全锁”，它能让共享资源在同一时间只能被一个线程访问。
比如，假设我们有一个计数器类，初始化计数值为 0。多个线程都来对这个计数器加 1。如果没有同步机制，两个线程可能会同时读到计数器的值为 0，各自加 1 后再设置回去，最终计数器的值可能还是 1，而不是预期的 2。但如果用 synchronized：
java复制
public class Counter {
    private int count = 0;

    public synchronized void increment() {
        count++;
    }

    public synchronized int getCount() {
        return count;
    }
}
这里的 increment() 和 getCount() 方法都被 synchronized 修饰。当一个线程进入 increment() 方法时，其他线程就不能再进入这个方法或者访问带有 synchronized 的其他方法，直到当前线程执行完毕。这样就能保证计数器的值正确增长，不会出现线程安全问题。
这种场景在 Android 开发中也很常见。比如在一个社交媒体 App 里，用户点赞和取消点赞的操作需要更新数据库中的点赞数，同时有多个用户操作时，就需要用 synchronized 类似的方式确保点赞数正确更新，避免数据混乱。



一、Java 基础语法相关问题
问：Java 中的基本数据类型有哪些？它们的默认值和大小分别是多少？
答：Java 中的基本数据类型一共有 8 种。
首先是 boolean 类型，它的默认值是 false，大小不确定，因为它只表示布尔值，就是 true 或 false。
然后是 char 类型，它的默认值是 '\u0000'，大小是 2 个字节。它可以用来存储单个字符，比如字母、数字或者符号。
接着是 byte 类型，它的默认值是 0，大小是 1 个字节，一般用来存储很小的整数数据。
short 类型的默认值也是 0，大小是 2 个字节，比 byte 类型能存储的数值范围大一点。
int 类型就比较常用了，默认值是 0，大小是 4 个字节，在整数运算中经常用到。
long 类型的默认值是 0L，大小是 8 个字节，它可以存储比 int 类型更大的整数，比如一些大范围的计数或者编号之类的。
float 类型默认值是 0.0f，大小是 4 个字节，用来存储单精度的浮点数，就是有小数的数值。
最后是 double 类型，默认值是 0.0，大小是 8 个字节，它是双精度浮点数，精度比 float 类型高，一般在需要高精度计算的时候用。
问：String 属于基础的数据类型吗？为什么？
答：String 不属于基础的数据类型。基础的数据类型就是刚才说的那 8 种，像 int、double 这些。String 是一个类，它是一个引用类型。简单来说，基础数据类型存储的是实实在在的值，比如一个整数或者一个字符。而 String 存储的是一个字符串对象的引用，也就是指向这个字符串在内存中的地址。比如 String s = "hello";，这里 s 其实是指向了一个存储着 "hello" 这个字符串的内存位置。而且 String 类有很多方法，比如 substring() 可以截取字符串的一部分，replace() 可以替换字符串中的某些字符，这些都说明它是一个功能丰富的类，不是简单的基本数据类型。
二、Java 内存管理与垃圾回收相关问题
问：请简单介绍一下 Java 内存模型的各个区域。
答：Java 内存模型主要分为几个区域。
首先是堆（Heap），这是所有对象分配内存的地方。就像一个大的仓库，我们创建的对象都放在里面。堆的特点是所有线程共享，也就是说不管有多少线程，它们要创建对象都得从堆里拿空间。而且堆的内存是由垃圾回收机制来管理的，当对象没有被引用了，垃圾回收器就会来清理这些对象占用的内存。
然后是栈（Stack），栈是每个线程私有的。它主要用于存储方法调用和局部变量。当一个方法被调用时，就会在栈上分配一块空间来存储这个方法的局部变量和一些操作信息。方法执行完后，这块空间就会被释放。栈的访问速度比堆快，因为它采用的是连续的内存空间，而且有固定的生命周期，就是方法的调用和结束。
还有方法区（Method Area），它也是所有线程共享的。方法区主要用于存储类的结构信息，比如类的静态变量、常量、方法代码等。简单来说，就是类的蓝图放在这个地方，当类被加载到内存中时，这些信息就会被放到方法区里。
另外还有程序计数器（Program Counter Register），它也是每个线程私有的。程序计数器的作用是指向当前线程正在执行的字节码指令的地址。也就是说，它就像一个指针，告诉我们线程现在运行到哪一步了。当线程切换时，程序计数器的值也会相应地改变，以便恢复到正确的执行位置。
问：垃圾回收机制是如何工作的？常见的 GC 算法有哪些？
答：垃圾回收机制主要是用来自动管理内存的。它的基本原理是找出那些不再被引用的对象，然后回收它们占用的内存。
常见的 GC 算法有几种。首先是标记 - 清除算法，这个算法就像在内存里做标记一样。它先从根节点（比如引用变量）开始，标记所有可达的对象。然后清除那些没有被标记的对象，也就是那些不再被引用的对象。这种方法简单直接，但是可能会产生内存碎片，因为清除对象后，内存空间可能会变得不连续。
然后是复制算法，它把内存分成两块相等的区域。在使用其中一块区域时，当这块区域满了，就把还存活的对象复制到另一块区域，然后把原来的区域清空。这样就不会有内存碎片的问题了。但是它的缺点是需要两倍的内存空间，而且如果存活对象很多，复制的开销也会比较大。
还有标记 - 整理算法，它先像标记 - 清除算法一样标记可达对象，然后把存活的对象移动到内存的一端，这样就可以避免内存碎片的问题。同时，它只需要一块内存空间，不像复制算法需要两块。不过，移动对象的过程可能会比较耗时。
最后是分代回收算法，这个算法是基于对象的生命周期来设计的。它把堆内存分为新生代和老年代。新生代存放新创建的对象，老年代存放经过多次垃圾回收后仍然存活的对象。在新生代，对象的死亡率比较高，所以一般使用复制算法来回收内存。在老年代，对象的存活率比较高，所以一般使用标记 - 整理算法来回收内存。这样可以提高垃圾回收的效率。
三、设计模式相关问题
问：什么是单例模式？如何确保线程安全？
答：单例模式是一种设计模式，它的目的是确保一个类只有一个实例，并且提供一个全局访问点。简单来说，就是这个类只能创建一个对象，不管我们在哪里调用，都只能得到这一个对象。
要确保线程安全，有几种方法。一种是使用懒汉式加双重检查锁。就是说，我们在创建单例实例的时候，先检查实例是否为 null，如果为 null，再进行同步操作。然后在同步块里再次检查实例是否为 null，如果是，才创建实例。这样可以避免多线程环境下创建多个实例的问题。代码大概是这样：
java复制
public class Singleton {
    private static volatile Singleton instance;

    private Singleton() {
    }

    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
这里用到了 volatile 关键字，它可以保证变量的可见性和禁止指令重排序，这样就能确保在多线程环境下单例的正确性。
还有一种是使用饿汉式，就是在类加载的时候就创建实例。这样因为实例是在类加载的时候就创建好了，所以天然就是线程安全的。代码大概是这样：
java复制
public class Singleton {
    private static final Singleton instance = new Singleton();

    private Singleton() {
    }

    public static Singleton getInstance() {
        return instance;
    }
}
不过，这种方式的缺点是不管我们用不用这个单例，它都会在类加载的时候创建实例，可能会浪费一些资源。
四、Java 8 新特性相关问题
问：Lambda 表达式的优点是什么？如何替代匿名类？
答：Lambda 表达式的主要优点是让代码更简洁、更易读。以前我们用匿名类的时候，需要写很多模板代码，比如 new Thread(new Runnable() { public void run() { ... } });。现在用 Lambda 表达式，就可以直接写成 new Thread(() -> { ... });。这样就省去了很多繁琐的代码，让我们的关注点更集中在具体的逻辑上。
Lambda 表达式可以替代匿名类，是因为它们都可以用来实现接口的方法。只要接口是函数式接口（也就是只有一个抽象方法的接口），我们就可以用 Lambda 表达式来替代匿名类。比如，Runnable 接口就是一个函数式接口，它只有一个 run() 方法。所以我们就可以用 Lambda 表达式来创建 Runnable 对象。而且 Lambda 表达式还可以和方法引用一起使用，让代码更加简洁。比如 Arrays.asList("a", "b", "c").forEach(System.out::println);，这里 System.out::println 就是一个方法引用，它替代了 Lambda 表达式 x -> System.out.println(x)。
五、Java 集合框架相关问题
问：为什么 HashMap 不是线程安全的？如何解决线程安全问题？
答：HashMap 不是线程安全的，主要是因为在多线程环境下，多个线程同时对 HashMap 进行操作时，可能会出现数据不一致的问题。比如，多个线程同时对 HashMap 进行 put 操作，可能会导致链表结构被破坏，或者出现数据丢失的情况。
要解决线程安全问题，有几种方法。一种是使用 ConcurrentHashMap，它是 HashMap 的线程安全版本。ConcurrentHashMap 使用了分段锁的技术，把整个哈希表分成多个段，每个段独立加锁。这样在多线程环境下，多个线程可以同时操作不同的段，提高了并发性能。
另一种方法是使用 Collections.synchronizedMap() 方法，它可以把一个普通的 HashMap 包装成线程安全的。不过，这种方法需要我们在每次操作时都进行同步，比如使用 synchronized 关键字。而且它的性能可能不如 ConcurrentHashMap。
还有一种方法是使用 Hashtable，它也是线程安全的。不过，Hashtable 已经被标记为过时了，不推荐在新的代码中使用。
